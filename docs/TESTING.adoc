= Testing
Dominik Nakamura <dominik.nakamura@trilliumsecure.com>
:toc: left
:homepage: http://trilliumsecure.com
:icons: font
:source-highlighter: pygments

== Unit tests

== Integration tests

== Setup

To enable test coverage reports, apply the JaCoCo plugin. This adds the `jacocoTestReport` task to gradle, which can be
run after the tests. If you already run the tests before applying the plugin, you have to run them again once.

[source,groovy]
----
apply plugin: 'jacoco'
----

For the testing classes add JUnit 5 as well as Mockito for mocking. This plugin is specifically made for Kotlin to ease
the use of the basic Mockito.

The Spring dependencies help in starting up a service with minimal setup to separately test single components.

[source,groovy]
----
testImplementation "com.nhaarman.mockitokotlin2:mockito-kotlin:$mockitoKotlinVersion"
testImplementation "org.junit.jupiter:junit-jupiter-api:$junitVersion"
testImplementation 'org.springframework.boot:spring-boot-starter-test'
testImplementation 'org.springframework.security:spring-security-test'
testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:$junitVersion"
----

Lastly tell Gradle to use JUnit 5 for testing and add the Kotlin Annotation Processor output to JaCoCo so it can find
the source code in its reports.

[source,groovy]
----
test {
    useJUnitPlatform()
}

jacocoTestReport {
    additionalSourceDirs = files("$buildDir/generated/source/kapt/main")
}
----

To make the `@BeforeEach` annotation work nicely with Kotlin, add the following line in the file
`junit-platform.properties` in the testing resources folder. Don't include any package names, but put it directly into
the root of the resources folder.

[source,properties]
----
junit.jupiter.testinstance.lifecycle.default=per_class
----

== Testing of different components

=== Mappers

Mappers are responsible for mapping from and to different data classes for backend, API, persistence, and so on. These
mappers are usually auto-generated by *Mapstruct* and often require special configuration thus should be tested for
correctness.

The tests normally take create an instance of a DTO class, map it to a persistence entity and lastly map it back to the
DTO. After that the instance should be exactly the same as in the beginning.

.Showcase of a simple mapper test
[source,kotlin]
----
@ExtendWith(SpringExtension::class)
class EventMapperTest {

    @TestConfiguration
    @ComponentScan(basePackageClasses = [EventMapper::class, UuidMapper::class]) // <1>
    class TestContextConfiguration

    @Autowired
    private lateinit var mapper: EventMapper // <2>

    @Test
    fun `GPS event should be same after mapping`() {
        val event = GpsEventProto.newBuilder() // <3>
            .setTimestamp(10)
            .setLatitude(11.111)
            .setLongitude(22.222)
            .build()

        val temp = mapper.gpsEvent(UUID(0, 0), event) // <4>
        val mapped = mapper.gpsEvent(temp) // <5>

        assertThat(mapped).isEqualTo(event) // <6>
    }
}
----
<1> Add a component scan for the mapper class to be tested, as well as all external mappers that live in other
    namespaces.
<2> Autowire the mapper to be tested.
<3> Create an instance of the class we want to test with all fields filled out.
<4> Map the instance to another class.
<5> Map the temporary new instance back to the original class.
<6> After mapping the entity to another one and back, verify it still contains the same data.

=== Services

The services contain the actual business logic and are the most important part to test. They require a lot of mocking,
to abstract away the persistence layer and focus on the actual business logic. As they include various functionality,
there is no defined pattern for these tests.

Most of them however, will start with some mocks to emulate the persistence and end with some asserts.

.Showcase of a simple service test
[source,kotlin]
----
@ExtendWith(SpringExtension::class)
class ModelServiceTest {

    @TestConfiguration
    @ComponentScan(basePackageClasses = [ModelMapper::class, UuidMapper::class]) // <1>
    class TestContextConfiguration {
        @Bean // <2>
        fun modelService(
            modelMapper: ModelMapper,
            vehicleModelRepository: VehicleModelRepository,
            vehicleRepository: VehicleRepository,
            uaaClient: UaaClient
        ) =
            ModelService(
                modelMapper,
                vehicleModelRepository,
                vehicleRepository,
                uaaClient
            )
    }

    @Autowired
    private lateinit var modelService: ModelService // <3>

    @MockBean
    private lateinit var vehicleRepository: VehicleRepository // <4>

    @MockBean
    private lateinit var vehicleModelRepository: VehicleModelRepository // <4>

    @MockBean
    private lateinit var uaaClient: UaaClient // <4>

    @Test
    fun `Updating a vehicle saves the new name`() {
        whenever(vehicleModelRepository.findById(any())).thenReturn( // <5>
            Optional.of(VehicleModel(name = "old"))
        )
        whenever(vehicleModelRepository.save(any<VehicleModel>())).then { it.arguments.first() }
        whenever(vehicleRepository.findByModelId(any())).thenReturn(listOf())

        val model = modelService.update( // <6>
            UUID.randomUUID(), VehicleModelProto.newBuilder()
                .setName("new")
                .build()
        )

        assertThat(model.name).isEqualTo("new") // <7>
    }
}
----
<1> Include the real mappers by adding their namespace to the component scan.
<2> Provide the service that has to be tested as a bean.
<3> Autowire the service into the test class for further testing.
<4> Mock all dependencies of the service (except the mappers).
<5> Return valid results from the repositories, so the service can work.
<6> Call the actual service.
<7> Verify the expected result.

=== Controllers

The controllers' main work is the handling of HTTP requests. Therefore the `MockMvc` class is used to perform requests
and validate the response. Most of these tests also verify that only one specific service got called once for each
endpoint. This is done to guarantee that the controllers don't contain much logic and focus on the routing and
transformation of HTTP requests.

.Showcase of a simple controller test
[source,kotlin]
----
@ExtendWith(SpringExtension::class)
@WebMvcTest(ModelController::class) // <1>
class ModelControllerTest {

    @TestConfiguration
    @Import(ProtobufConfiguration::class) // <2>
    class TestContextConfiguration

    @Autowired
    private lateinit var mvc: MockMvc // <3>

    @MockBean
    private lateinit var modelService: ModelService // <4>

    @MockBean
    private lateinit var uaaClient: UaaClient // <4>

    @Test
    @WithMockUser
    fun `Create a new model`() {
        whenever(modelService.createModel(any())).then { // <5>
            VehicleModelProto.newBuilder()
                .setId(UUID.randomUUID().toString())
                .setName(it.getArgument(0))
                .build()
        }

        mvc.perform( // <6>
            post("/api/vehicles/models")
                .with(csrf()) // <7>
                .content("test")
                .accept(MediaType.APPLICATION_JSON) // <8>
        )
            .andExpect(status().isOk) // <9>
            .andExpect(jsonPath("$.name", equalTo("test"))) // <10>

        verify(modelService, only()).createModel(any()) // <11>
    }
}
----
<1> Use the `@WebMvcTest` annotation to enable the `MockMvc` class for easy HTTP request testing.
<2> As most Controllers support Protobuf, this configuration needs to be imported, otherwise most requests fail with
    encoding errors.
<3> Autowire the `MockMvc` class for easy testing.
<4> Mock all dependencies of the controller.
<5> Create a proper response so it can be handled by the controller.
<6> Perform the actual HTTP request.
<7> CSRF must be enabled for anything but GET requests.
<8> Accept JSON so we can use jsonPath functions in the validation step.
<9> Response status should be OK.
<10> Content should contain the field "name" with value "test".
<11> Verify that the modelService was the only instance that got called.
